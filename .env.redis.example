# Redis Configuration for Distributed Cache and Queue
# Copy relevant sections to your .env file to enable Redis/BullMQ

# ============================================================================
# REDIS CACHE CONFIGURATION
# ============================================================================

# Enable Redis cache (set to 'true' to use Redis, 'false' for in-memory)
REDIS_ENABLED=false

# Redis connection settings
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=

# Redis database number for cache (0-15)
REDIS_DB=0

# Key prefix for cache entries (prevents collisions with other apps)
REDIS_KEY_PREFIX=tempdownloads:cache:

# ============================================================================
# BULLMQ JOB QUEUE CONFIGURATION
# ============================================================================

# Enable BullMQ distributed queue (set to 'true' to use BullMQ, 'false' for in-memory)
BULLMQ_ENABLED=false

# BullMQ uses the same Redis connection settings as above but different DB
# Redis database number for job queue (0-15, should differ from REDIS_DB)
# Note: If using same Redis instance, use different DB numbers for cache vs queue
# REDIS_DB=1  # Uncomment and set if you want queue on different DB

# ============================================================================
# PRODUCTION REDIS SETTINGS
# ============================================================================

# For production with Redis cluster or managed Redis (AWS ElastiCache, Azure Redis, etc.):
# REDIS_ENABLED=true
# BULLMQ_ENABLED=true
# REDIS_HOST=your-redis-cluster.example.com
# REDIS_PORT=6379
# REDIS_PASSWORD=your-secure-password
# REDIS_DB=0
# REDIS_KEY_PREFIX=tempdownloads:prod:

# ============================================================================
# REDIS CLUSTER CONFIGURATION (Advanced)
# ============================================================================

# For Redis Cluster, you'll need to modify redisCache.js and bullQueue.js
# to use cluster configuration instead of single host:
#
# Example cluster config:
# REDIS_CLUSTER_NODES=node1:6379,node2:6379,node3:6379
# REDIS_CLUSTER_PASSWORD=your-password

# ============================================================================
# MONITORING & OBSERVABILITY
# ============================================================================

# Cache hit rate: Monitor via cache.getStats()
# Queue stats: Monitor via queue.getQueueStats()
# Redis monitoring: Use redis-cli, RedisInsight, or cloud provider tools

# ============================================================================
# MIGRATION CHECKLIST
# ============================================================================

# 1. Install dependencies:
#    npm install ioredis bullmq
#
# 2. Set up Redis:
#    - Local: docker run -d -p 6379:6379 redis:7-alpine
#    - Cloud: AWS ElastiCache, Azure Cache for Redis, Redis Cloud
#
# 3. Update .env with Redis settings above
#
# 4. Test cache:
#    REDIS_ENABLED=true npm start
#    - Check logs for "Using Redis cache backend"
#    - Monitor cache hit rates
#
# 5. Test queue:
#    BULLMQ_ENABLED=true npm start
#    - Check logs for "Using BullMQ distributed queue backend"
#    - Verify jobs are processing
#
# 6. Monitor production:
#    - Set up Redis monitoring (CloudWatch, Azure Monitor, etc.)
#    - Monitor memory usage
#    - Set up alerts for high error rates
#
# 7. Scale horizontally:
#    - Deploy multiple server instances
#    - All instances connect to same Redis
#    - Jobs are automatically distributed across workers

# ============================================================================
# FALLBACK BEHAVIOR
# ============================================================================

# If Redis connection fails:
# - Cache: Automatically falls back to in-memory cache
# - Queue: Automatically falls back to in-memory queue
# - Application continues running (graceful degradation)
# - Check logs for fallback warnings

# ============================================================================
# PERFORMANCE TUNING
# ============================================================================

# Cache TTL (in queryCache vs redisCache):
# - queryCache: TTL in milliseconds (defaultTTL: 300000 = 5 minutes)
# - redisCache: TTL in seconds (defaultTTL: 300 = 5 minutes)
# - Unified cache.js handles conversion automatically

# Queue concurrency:
# - Memory queue: concurrency: 5 (hardcoded in jobQueue.js)
# - BullMQ: concurrency: 5 per worker (can scale by adding more workers)

# Redis connection pooling:
# - ioredis automatically manages connection pool
# - Default: No need to configure unless high traffic

# ============================================================================
# COST ESTIMATION
# ============================================================================

# Redis Cloud Free Tier:
# - 30MB storage
# - Suitable for small deployments (<1000 users)
#
# AWS ElastiCache t4g.micro:
# - ~$12/month
# - 555MB memory
# - Suitable for medium deployments (<10,000 users)
#
# Azure Cache for Redis Basic C0:
# - ~$16/month
# - 250MB memory
# - Suitable for small-medium deployments

# ============================================================================
# SECURITY BEST PRACTICES
# ============================================================================

# 1. Always use password authentication in production
# 2. Use TLS/SSL for Redis connections in production
# 3. Restrict Redis network access (VPC, security groups)
# 4. Use different Redis DB numbers for cache vs queue
# 5. Rotate Redis passwords regularly
# 6. Monitor for suspicious activity
# 7. Set up Redis maxmemory policies (eviction)
